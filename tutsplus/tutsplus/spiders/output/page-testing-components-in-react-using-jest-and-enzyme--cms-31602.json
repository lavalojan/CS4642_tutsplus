{"fileName": "testing-components-in-react-using-jest-and-enzyme--cms-31602", "title": ["Testing Components in React Using Jest and Enzyme"], "author": ["Manjunath M"], "auther_details": ["Kerala, India"], "length": ["Medium"], "body": ["This is the second part of the series on Testing Components in React. If you have prior experience with Jest, you can skip ahead and use the GitHub code as a starting point.\u00a0", "In the\u00a0", "previous article", ", we covered the basic principles and ideas behind test-driven development. We also set up the environment and the tools required for running tests in React. The toolset included Jest, ReactTestUtils, Enzyme, and react-test-renderer.\u00a0", "We then wrote a couple of tests for a demo application using ReactTestUtils and discovered its shortcomings compared to a more robust library like Enzyme.", "In this post, we'll get a deeper understanding of testing components in React by writing more practical and realistic tests. You can head to GitHub and ", "clone my repo", " before getting started.", "Enzyme.js is an open-source library maintained by Airbnb, and it's a great resource for React developers. It uses the ReactTestUtils API underneath, but unlike ReactTestUtils, Enzyme offers a high-level API and easy-to-understand syntax. Install Enzyme if you haven't already.", "The Enzyme API exports three types of rendering options:", "Shallow rendering", " is used to render a particular component in isolation. The child components won't be rendered, and hence you won't be able to assert their behavior. If you're going to focus on unit tests, you'll love this. You can shallow render a component like this:", "Full DOM rendering", " generates a virtual DOM of the component with the help of a library called jsdom. You can avail this feature by replacing the\u00a0", "shallow()", " method with ", "mount()", " in the above example. The obvious benefit is that you can render the child components also. If you want to test the behavior of a component with its children, you should be using this.\u00a0", "Static rendering", " is used to render react components to static HTML. It's implemented using a library called Cheerio, and you can read more about it in ", "the docs", ".\u00a0", "Here are the tests that we wrote in the last tutorial:", "The first test checks whether the ", "ProducerHeader", " component has an ", "<h2>", " tag, and the second one finds whether it has a CSS class named ", "title", ". The code is hard to read and understand.\u00a0", "Here are the tests rewritten using Enzyme.", "First, I created a shallow-rendered DOM of the\u00a0", "<ProductHeader/>", "\u00a0component using ", "shallow()", " and stored it in a variable. Then, I used the ", ".find()", " method to find a node with tag 'h2'. It queries the DOM to see if there's a match. Since there is only one instance of the node, we can safely assume that ", "node.length", " will be equal to 1.", "The second test is very similar to the first one. The ", "hasClass('title')", " method returns whether the current node has a ", "className", " prop with value 'title'. We can verify the truthfulness using\u00a0", "toBeTruthy()", ". \u00a0", "Run the tests using ", "yarn test", ", and both the tests should pass.\u00a0", "Well done! Now it's time to refactor the code. This is important from a tester's perspective because readable tests are easier to maintain. In the above tests, the first two lines are identical for both the tests. You can refactor them by using a ", "beforeEach()", " function. \u00a0As the name suggests, the ", "beforeEach", " function gets called once before each spec in a describe block is executed.\u00a0", "You can pass an arrow function to ", "beforeEach()", " like this.", "Let's write a few unit tests for the ", "ProductDetails", " component. It is a presentational component that displays the details of each individual product.\u00a0", "The unit test will try to assert the following assumptions:", "Here is the bare-bones structure of the test. The first ", "beforeEach()", " stores the product data in a variable, and the second one mounts the component.", "The first test is easy:", "Here we use the ", "props()", " method which is handy for getting the props of a component.", "For the second test, you can query elements by their class names and then check whether the product's name, description etc. are part of that element's ", "innerText", ".\u00a0", "The ", "text()", " method is particularly useful in this case to retrieve the inner text of an element. Try writing an expectation for the ", "product.status()", " and see if all the tests are passing.", "For the final test, we're going to mount the ", "ProductDetails", " component without any props. Then we're going to look for a class named '.product-error' and check if it contains the text \"Sorry, Product doesn't exist\".", "That's it. We've successfully tested the ", "<ProductDetails />", " component in isolation. Tests of this type are known as unit tests.", "We just learned how to test props. But to truly test a component in isolation, you also need to test the callback functions. In this section, we'll write tests for the ", "ProductList", " component and create stubs for callback functions along the way. Here are the assumptions that we need to assert.", "Let's create a\u00a0", "beforeEach()", "\u00a0function that fills in mock product data for our tests.", "Now, let's mount our component in another ", "beforeEach()", " block.", "The ", "ProductList", " receives the product data through props. In addition to that, it receives a callback from the parent. Although you could write tests for the parent's callback function, that's not a great idea if your aim is to stick to unit tests. Since the callback function belongs to the parent component, incorporating the parent's logic will make the tests complicated. Instead, we are going to create a stub function.", "A stub is a dummy function that pretends to be some other function. This allows you to independently test a component without importing either parent or child components. In the example above, we created a stub function called ", "handleProductClick", " by invoking", " jest.fn()", ".\u00a0", "Now we just need to find the all the ", "<a>", " elements in the DOM and simulate a click on the first ", "<a>", " node. After being clicked, we'll check if ", "handleProductClick()", " was invoked. If yes, it's fair to say our logic is working as expected.", "Enzyme lets you easily simulate user actions such as clicks using\u00a0", "simulate()", "\u00a0method.\u00a0", "handlerProductClick.mock.calls.length", "\u00a0returns the number of times the mock function was called. We expect it to be equal to 1.", "The other test is relatively easy. You can use the ", "find()", " method to retrieve all ", "<a>", " nodes in the DOM. The number of ", "<a>", " nodes should be equal to the length of the productData array that we created earlier.\u00a0", "Next up, we're going to test the ", "ProductContainer", "\u00a0component. It has a state, a lifecycle hook, and a class method. Here are the assertions that need to be verified:", "To check whether ", "componentDidMount", " was called, we're going to spy on it. Unlike a stub, a\u00a0spy is used when you need to test an existing function. Once the spy is set, you can write assertions to confirm whether the function was called.", "You can spy on a function as follows:", "The first parameter to ", "jest.spyOn", " is an object that defines the prototype of the class that we're spying on. The second one is the name of the method that we want to spy.\u00a0", "Now render the component and create an assertion to check whether spy was called.", "To check that the component's state is populated after the component mounts, we can use Enzyme's ", "state()", " method to retrieve everything in the state.\u00a0", "The third one is a bit tricky. We need to verify that ", "handleProductClick", " is working as expected. If you head over to the code, you'll see that the ", "handleProductClick()", " method takes a product id as input, and then updates ", "this.state.selectedProduct", " with the details of that product.\u00a0", "To test this, we need to invoke the component's method, and you can actually do that by calling\u00a0", "component.instance().handleProductClick()", ". We'll pass in a sample product id. In the example below, we use the id of the first product. Then, we can test whether the state was updated to confirm that the assertion is true. Here's the whole code:", "We've written 10 tests, and if everything goes well, this is what you should see:", "Phew! We've covered almost everything that you need to know to get started with writing tests in React using Jest and Enzyme. Now might be a good time to head over to the ", "Enzyme website", " to have a deeper look at their API.", "What are your thoughts on writing tests in React? I'd love to hear them in the comments."], "pubished_date": ["2 days ago"]}