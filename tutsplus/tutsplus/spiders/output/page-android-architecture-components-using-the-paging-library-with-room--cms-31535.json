{"fileName": "android-architecture-components-using-the-paging-library-with-room--cms-31535", "title": ["Android Architecture Components: Using the Paging Library With Room"], "author": ["Chike Mgbemena "], "auther_details": ["Mobile Developer, Nigeria"], "length": ["Intermediate", "Medium"], "body": ["In this tutorial, I'll show you how to use the Paging library from the Android Architecture Components with a Room-backed database in an Android app.\u00a0", "You'll learn how to use the Paging library to\u00a0efficiently load large data sets from a Room-backed database\u2014giving your users a smoother experience while scrolling in a RecyclerView.\u00a0", "To be able to follow this tutorial, you'll need:", "If you haven't learnt about the architecture components, you are strongly advised to check out our\u00a0", "awesome series all about Android Architecture Components", "\u00a0by Tin Megali. Make sure you go dive in!\u00a0", "A sample project for this tutorial can be found on\u00a0our GitHub repo", "\u00a0so you can easily follow along.", "The Paging library is another library added to the ", "Architecture Components", ". The library helps efficiently manage the loading and display of a large data set in the ", "RecyclerView", ". According to the official docs:", "If any part of your Android app is going to display a large dataset from either a local or remote data source but displays only part of it at a time, then you should consider using the Paging library. This will help improve the performance of your app!\u00a0", "Now that you've seen an introduction to the Paging library, you might ask, why use it? Here are some reasons why you should consider using it in loading large data sets in a ", "RecyclerView", ".\u00a0", "It won't be efficient when working with a large amount of data, as the underlying data source retrieves all the data, even though only a subset of that data is going to be displayed to the user. In such a situation, we should consider paging the data instead.\u00a0", "Fire up your Android Studio 3 and create a new project with an empty activity called\u00a0", "MainActivity", ".\u00a0Make sure to check ", "Include Kotlin support", ".\u00a0", "After creating a new project, add the following dependencies in your ", "build.gradle", ". In this tutorial, we are using the latest Paging library version 1.0.1, while Room is 1.1.1 (as of this writing).\u00a0", "These artifacts are available at Google\u2019s Maven repository.\u00a0", "By adding the dependencies, we have taught Gradle how to find the library. Make sure\u00a0you remember to sync your project after adding them.\u00a0", "Create a new Kotlin data class ", "Person", ". For simplicity's sake, our ", "Person", " entity has just\u00a0two fields:", "In addition, include a ", "toString(", "\u00a0method that simply returns the ", "name", ".\u00a0", "As you know, for us to access our app's data with the Room library, we need data access objects (DAOs). In our own case, we have created a\u00a0", "PersonDao", ".\u00a0", "In our ", "PersonDao", " class, we have two ", "@Query", " methods. One of them is\u00a0", "getAll()", ", which\u00a0returns a ", "LiveData", " that holds a list of ", "Person", " objects. The other one is\u00a0", "getAllPaged()", ", which returns a ", "DataSource.Factory", ".\u00a0", "According to the official docs, the ", "DataSource", " class is the:", "A ", "PagedList", " is a special kind of ", "List", " for showing paged data in Android:\u00a0", "We called the ", "Factory", " static method in the ", "DataSource", " class, which serves as a factory (creating objects without having to specify the exact class of the object that will be created) for the ", "DataSource", ".\u00a0This static method takes in two data types:", "Here's is what our Room database class ", "AppDatabase", " looks like:\u00a0", "Here we have created a single instance of our database and pre-populated it with data using the new ", "WorkManager API", ". Note that the data pre-populated is just a list of 1,000 names (dive into the sample source code provided to learn more).\u00a0", "For our UI to store, observe, and serve data in a lifecycle-conscious way, we need a ", "ViewModel", ". Our ", "PersonsViewModel", ", which extends the ", "AndroidViewModel", " class, is going to function as our ", "ViewModel", ".\u00a0", "In this class, we have a single field called ", "personsLiveData", ". This field is simply a ", "LiveData", " that holds a ", "PagedList", " of\u00a0", "Person", " objects. Because this is a ", "LiveData", ", our UI (the ", "Activity", " or ", "Fragment", ") is going to observe this data by calling the getter method ", "getPersonsLiveData()", ".\u00a0", "We initialized ", "personsLiveData", " inside the ", "init", " block. Inside this block, we\u00a0get the ", "DataSource.Factory", " by calling the\u00a0", "AppDatabase", " singleton for the\u00a0", "PersonDao", "\u00a0object. When we get this object, we\u00a0call ", "getAllPaged()", ".\u00a0", "We then create a ", "LivePagedListBuilder", ". Here's what the official documentation says about a ", "LivePagedListBuilder", ":\u00a0", "We supply its constructor a ", "DataSource.Factory", " as the first argument and the page size as the second argument (in our own case, the page size will be 50). Typically, you should choose a size that's higher than the maximum number that you might display at once to the user. In the end, we call ", "build()", " to construct and return to us a ", "LiveData<PagedList>", ".\u00a0", "To show our ", "PagedList", " data in a ", "RecyclerView", ", we need a ", "PagedListAdapter", ".\u00a0Here's a clear definition of this class from the official docs:", "So we create a ", "PersonAdapter", " that extends\u00a0", "PagedListAdapter", ".", "PagedListAdapter", " is used just like any other subclass of ", "RecyclerView.Adapter", ". In other words, you have to implement the methods\u00a0", "onCreateViewHolder()", " and ", "onBindViewHolder()", ".\u00a0", "To extend the ", "PagedListAdapter", " abstract class, you will have to supply\u2014in its constructor\u2014the type of ", "PageLists", " (this should be a plain old Java class: a\u00a0POJO) and also a class that extends the ", "ViewHolder", " that will be used by the adapter. In our case, we gave it ", "Person", " and ", "PersonViewHolder", " as the first and second argument respectively.\u00a0", "Note that ", "PagedListAdapter", " requires you pass it a\u00a0", "DiffUtil.ItemCallback", " to the ", "PageListAdapter", " constructor. ", "DiffUtil", " is a ", "RecyclerView", " utility class that can calculate the difference between two lists and output a list of update operations that converts the first list into the second one. ", "ItemCallback", " is an inner abstract static class (inside ", "DiffUtil", ") used for calculating the diff between two non-null items in a list.\u00a0", "Specifically, we supply ", "PersonDiffCallback", " to our\u00a0", "PagedListAdapter", " constructor.\u00a0", "Because we are implementing ", "DiffUtil.ItemCallback", ", we have to implement two methods: ", "areItemsTheSame()", " and ", "areContentsTheSame()", ".\u00a0", "Our ", "PersonViewHolder", " inner class is just a typical\u00a0", "RecyclerView.ViewHolder", ". It's responsible for binding data as needed from our model into the widgets for a row in our list.\u00a0", "In our ", "onCreate()", " of our ", "MainActivity", ", we simply did the following:", "Finally, when you run the app, here's the result:", "While scrolling, Room is able to prevent gaps by loading 50 items at a time and making\u00a0them available to our ", "PersonAdapter", ", which is a subclass of ", "PagingListAdapter", ". But note that not\u00a0all data sources will be loaded quickly. The loading speed also depends on the processing power of the Android device.\u00a0", "If you're using or want to use RxJava in your project, the paging library includes another useful artifact:\u00a0", "RxPagedListBuilder", ". You use this artifact instead of\u00a0", "LivePagedListBuilder", " for RxJava support.\u00a0", "You simply create an instance of\u00a0", "RxPagedListBuilder", ", supplying the same arguments as you would for\u00a0", "LivePagedListBuilder", "\u2014the ", "DataSource.Factory", " and the page size. You then call\u00a0", "buildObservable()", " or ", "buildFlowable()", " to return an ", "Observable", " or\u00a0", "Flowable", "\u00a0for your ", "PagedList", " respectively.\u00a0", "To explicitly provide the\u00a0", "Scheduler", " for the data loading work, you call the setter method\u00a0", "setFetchScheduler()", ". To also provide the ", "Scheduler", " for delivering the result (e.g.\u00a0", "AndroidSchedulers.mainThread()", "), simply call\u00a0", "setNotifyScheduler()", ".\u00a0By default, ", "setNotifyScheduler()", " defaults to the UI thread, while ", "setFetchScheduler()", " defaults to the I/O thread pool.\u00a0", "In this tutorial, you learned how to easily use the Paging component from the Android Architecture Components (which are part of\u00a0", "Android Jetpack", ") with Room. This helps us efficiently load large data sets from the local database to enable a smoother user experience while scrolling through a list in the ", "RecyclerView", ".\u00a0", "I highly recommend\u00a0checking out the ", "official documentation", " to learn more about the Paging library in Android."], "pubished_date": ["5 days ago"]}